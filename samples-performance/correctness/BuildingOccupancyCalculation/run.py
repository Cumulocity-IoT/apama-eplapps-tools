# Copyright (c) 2021-present Cumulocity GmbH, Duesseldorf, Germany and/or its affiliates and/or their licensors.

# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
# file except in compliance with the License. You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed under the
# License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied.
# See the License for the specific language governing permissions and limitations under the License.

from pysys.constants import *
from apamax.eplapplications import EPLApps
from apamax.eplapplications.basetest import ApamaC8YBaseTest
import os, time

class PySysTest(ApamaC8YBaseTest):

	# The type of ManagedObjects representing a building.
	buildingType = 'type_building'
	# The type of ManagedObjects representing an access point.
	accessPointType = 'type_access_point'
	# The type of measurements containing the count of people entered and exited a building via an access point.
	accessPointMeasurementType = 'building_entry_exit'
	# The measurement fragments containing the count of people who entered and exited a building via an access point.
	accessPointMeasurementFragment = 'access_point_crossed'
	# The measurement series containing the count of people who entered a building via an access point.
	accessPointEnteredSeries = 'people_entered'
	# The measurement series containing the count of people who exited a building via an access point.
	accessPointExitedSeries = 'people_exited'

	# The type of measurement generated by buildings with total occupancy count of the building.
	buildingMeasurementType = 'building_population'
	# The fragment of measurements generated by buildings.
	buildingMeasurementFragment = 'number_of_people'
	# The series of measurements generated by buildings.
	buildingMeasurementSeries = 'count'

	def execute(self):
		# Prepare the tenant for the test run.
		self.prepareTenant()
		
		# Create devices for buildings and their access points before EPL Apps are 
		# deployed as they look up devices at the start.
		# Create a building with 3 access points.
		accessPoints = [self.createTestDevice(f'accesspoint_{j}', type=self.accessPointType) for j in range(3)]
		building = self.createTestDevice(f'building', type=self.buildingType, children=accessPoints)

		self.log.info(f'Building {building} created with access points {accessPoints}')

		# Configure the app by replacing the placeholder values with the actual configured values
		appConfiguration = {
			'BUILDING_MO_TYPE': self.buildingType,
			'ACCESS_POINT_MO_TYPE': self.accessPointType,

			'ACCESS_POINT_MEASUREMENT_TYPE': self.accessPointMeasurementType,
			'ACCESS_POINT_MEASUREMENT_FRAGMENT': self.accessPointMeasurementFragment,
			'ACCESS_POINT_ENTERED_SERIES': self.accessPointEnteredSeries,
			'ACCESS_POINT_EXITED_SERIES': self.accessPointExitedSeries,

			'BUILDING_MEASUREMENT_TYPE': self.buildingMeasurementType,
			'BUILDING_MEASUREMENT_FRAGMENT': self.buildingMeasurementFragment,
			'BUILDING_MEASUREMENT_SERIES': self.buildingMeasurementSeries,
		}

		self.copyWithReplace(os.path.join(self.project.EPL_APPS, 'BuildingOccupancyCalculation.mon'),
			os.path.join(self.output, 'BuildingOccupancyCalculation.mon'), replacementDict=appConfiguration)

		appConfiguration['TEST_BUILDING_ID'] = building
		appConfiguration['TEST_ACCESS_POINT_ID_1'] = accessPoints[0]
		appConfiguration['TEST_ACCESS_POINT_ID_2'] = accessPoints[1]
		appConfiguration['TEST_ACCESS_POINT_ID_3'] = accessPoints[2]
		self.copyWithReplace(os.path.join(self.input, 'BuildingOccupancyCalculationTest.mon'),
			os.path.join(self.output, 'BuildingOccupancyCalculationTest.mon'), replacementDict=appConfiguration)

		# Deploy the sample app.
		eplapps = EPLApps(self.platform.getC8YConnection())

		eplapps.deploy(os.path.join(self.output, "BuildingOccupancyCalculation.mon"), name='PYSYS_AppUnderTest', redeploy=True, description='Application under test, injected by test framework')
		self.waitForGrep(self.platform.getApamaLogFile(), expr='Added monitor eplfiles.PYSYS_AppUnderTest', errorExpr=['Error injecting monitorscript from file PYSYS_AppUnderTest'])

		eplapps.deploy(os.path.join(self.output, "BuildingOccupancyCalculationTest.mon"), name='PYSYS_TestCase', redeploy=True, description='Test case, injected by test framework')
		self.waitForGrep(self.platform.getApamaLogFile(), expr='Added monitor eplfiles.PYSYS_TestCase', errorExpr=['Error injecting monitorscript from file PYSYS_TestCase'])

		# Delete the sample app at the end of the test.
		self.addCleanupFunction(lambda: eplapps.delete('PYSYS_AppUnderTest'))
		self.addCleanupFunction(lambda: eplapps.delete('PYSYS_TestCase'))

		self.waitForGrep(self.platform.getApamaLogFile(), expr="Removed monitor eplfiles.PYSYS_TestCase")

	def validate(self):
		# check none of the tests failed
		self.assertGrep(self.platform.getApamaLogFile(), expr=' (ERROR|FATAL) .* eplfiles\.', contains=False)
		
