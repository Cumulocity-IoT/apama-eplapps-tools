/*
 Copyright (c) 2020-present Cumulocity GmbH, Duesseldorf, Germany and/or its affiliates and/or their licensors.
 Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
 file except in compliance with the License. You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software distributed under the
 License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 either express or implied.
 See the License for the specific language governing permissions and limitations under the License.
*/

using com.apama.cumulocity.Util;
using com.apama.cumulocity.Measurement;
using com.apama.cumulocity.MeasurementValue;
using com.apama.cumulocity.ObjectCommitted;
using com.apama.cumulocity.ObjectCommitFailed;

monitor BuildingOccupancyCalculationTest {

	constant string ACCESS_POINT_MEASUREMENT_TYPE := "@ACCESS_POINT_MEASUREMENT_TYPE@";
	constant string ACCESS_POINT_MEASUREMENT_FRAGMENT := "@ACCESS_POINT_MEASUREMENT_FRAGMENT@";
	constant string ACCESS_POINT_ENTERED_SERIES := "@ACCESS_POINT_ENTERED_SERIES@";
	constant string ACCESS_POINT_EXITED_SERIES := "@ACCESS_POINT_EXITED_SERIES@";

	constant string BUILDING_MEASUREMENT_TYPE := "@BUILDING_MEASUREMENT_TYPE@";
	constant string BUILDING_MEASUREMENT_FRAGMENT := "@BUILDING_MEASUREMENT_FRAGMENT@";
	constant string BUILDING_MEASUREMENT_SERIES := "@BUILDING_MEASUREMENT_SERIES@";

	constant float MEASUREMENT_WAIT_DURATION := 30.0;

	constant string buildingId := "@TEST_BUILDING_ID@";
	constant string accessPointId1 := "@TEST_ACCESS_POINT_ID_1@";
	constant string accessPointId2 := "@TEST_ACCESS_POINT_ID_2@";
	constant string accessPointId3 := "@TEST_ACCESS_POINT_ID_3@";

	action onload()	{
		// Send measurements from various access points
		sendMeasurementAfter(accessPointId1, 10, 0, 0.0);
		sendMeasurementAfter(accessPointId1, 12, 7, 0.1);
		sendMeasurementAfter(accessPointId2, 0, 5, 0.3);
		sendMeasurementAfter(accessPointId3, 4, 1, 0.1);
		sendMeasurementAfter(accessPointId2, 2, 5, 0.5);
		sendMeasurementAfter(accessPointId1, 15, 10, 0.8);
		sendMeasurementAfter(accessPointId3, 6, 3, 0.6);
		sendMeasurementAfter(accessPointId2, 7, 7, 1.0);

		// Listen for measurements generated by the building and check if it is equal to expected value. If we did not
		// receive measurement with expected value within specified time, the test failed
		on all Measurement(source=buildingId, type=BUILDING_MEASUREMENT_TYPE) as m {
			if m.measurements[BUILDING_MEASUREMENT_FRAGMENT][BUILDING_MEASUREMENT_SERIES].value = 8.0 {
				 log "Got expected number of people inside the building - PASSED" at INFO;
				 die;
			}
		}

		on wait(MEASUREMENT_WAIT_DURATION) {
			log "Failed to receive measurement with total occupancy count within the wait duration - FAILED" at ERROR;
			die;
		}
	}

	/**
	 * Creates and schedules sending of a measurement after specified time.
	 * @param accessPointId The source of the measurement
	 * @param enteredVal The number of people who entered the building using this access point
	 * @param exitedVal The number of people who exited the building using this access point
	 * @param waitTime Time in seconds to wait before sending the measurement
	 */
	action sendMeasurementAfter(string accessPointId, integer enteredVal, integer exitedVal, float waitTime) {
		// Create measurement to be sent
		Measurement m := new Measurement;
		m.source := accessPointId;
		m.time := currentTime;
		m.type := ACCESS_POINT_MEASUREMENT_TYPE;
		dictionary<string, MeasurementValue> series := m.measurements.getOrAddDefault(ACCESS_POINT_MEASUREMENT_FRAGMENT);

		if enteredVal != 0 {
			series.getOrAddDefault(ACCESS_POINT_ENTERED_SERIES).value := enteredVal.toFloat();
		}

		if exitedVal != 0 {
			series.getOrAddDefault(ACCESS_POINT_EXITED_SERIES).value := exitedVal.toFloat();
		}

		// Wait for specified time before sending the measurement
		on wait(waitTime) {
			integer reqId := Util.generateReqId();
			send m.withResponse(reqId, new dictionary<string, string>) to Measurement.SEND_CHANNEL;

			// Listener for if creation of measurement fails
			on ObjectCommitFailed(reqId=reqId) as resp
			and not ObjectCommitted(reqId=reqId) {
				log "Unable to create measurement, reason : " + resp.toString() at ERROR;
				// Cause test to fail early, rather than wait for timeout
				die;
			}
		}
	}
}